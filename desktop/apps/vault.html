<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>VAULT</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="vault.css">
</head>

<body>
  <div id="vaultRoot">
    <div class="vault-frame">
      <div class="vault-title">
        VAULT ACCESS NODE
      </div>
      <div class="vault-graph">
        <div class="vault-map" id="vaultGraph"></div>
      </div>
      <div class="vault-panel">
        <p class="vault-prompt">Select a node.</p>
        <div class="question-panel hidden" id="questionPanel">
          <p id="questionText"></p>
          <input
            type="text"
            id="answerInput"
            autocomplete="off"
            spellcheck="false"
          >
          <button id="submitAnswer">
            SUBMIT
          </button>
          <div id="feedback"></div>
        </div>
      </div>
    </div>
  </div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyBWWUW8Q-Y45U6WNlzL0-nkKDrkErcsf88",
  authDomain: "vaultgri.firebaseapp.com",
  projectId: "vaultgri",
  storageBucket: "vaultgri.firebasestorage.app",
  messagingSenderId: "390092427827",
  appId: "1:390092427827:web:6871164cf35f62347e8946",
  measurementId: "G-DQ80LXBBEP"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const vaultDoc = doc(db, "vault", "progress");

const branches = [
  ["1946", "preservation", "valentine"],
  ["obsolescence", "ebb-0", "watcher"],
  ["continuity", "echo", "delta-black"],
  ["1972", "observer", "human error"]
];

const questions = [
  ["DELTA founding year?", "Original directive?", "Who signed the charter?"],
  ["Primary threat?", "First system name?", "Hidden protocol?"],
  ["EBB obsession?", "Failed experiment?", "Lost archive?"],
  ["Monitoring began?", "System anomaly?", "Trust breach?"]
];

const finalQuestion = {
  q: "FINAL KEY PHRASE",
  a: "always watching"
};

const graph = document.getElementById("vaultGraph");
const panel = document.getElementById("questionPanel");
const questionText = document.getElementById("questionText");
const input = document.getElementById("answerInput");
const submitBtn = document.getElementById("submitAnswer");
const feedback = document.getElementById("feedback");

let currentNode = null;
let globalData = { unlocked: {} };

const CENTER_X = 300;
const CENTER_Y = 210;
const RADIUS = 160;

const branchAngles = [-135, -45, 135, 45];
const stepOffsets = [0.45, 0.75, 1.0];

function polar(angleDeg, dist) {
  const r = angleDeg * Math.PI / 180;
  return [
    CENTER_X + Math.cos(r) * dist,
    CENTER_Y + Math.sin(r) * dist
  ];
}

function drawConnection(x1, y1, x2, y2) {
  const line = document.createElement("div");
  const dx = x2 - x1;
  const dy = y2 - y1;

  line.className = "connection";
  line.style.width = Math.hypot(dx, dy) + "px";
  line.style.left = x1 + "px";
  line.style.top = y1 + "px";
  line.style.transform = `rotate(${Math.atan2(dy, dx)}rad)`;

  graph.appendChild(line);
}

function createNode(id, x, y, isFinal = false) {
  const n = document.createElement("div");
  n.className = "node" + (isFinal ? " final" : "");
  n.style.left = (x - 28) + "px";
  n.style.top = (y - 28) + "px";
  n.dataset.id = id;

  if (globalData.unlocked[id]) {
    n.classList.add("unlocked");
  }

  n.onclick = () => openNode(id, isFinal);
  graph.appendChild(n);
  return n;
}

async function loadProgress(){
  const snap = await getDoc(vaultDoc);
  globalData = snap.exists() ? snap.data() : { unlocked: {} };
}

async function unlock(id){
  globalData.unlocked[id] = true;
  await setDoc(vaultDoc, globalData, { merge: true });
}

/* ===== RENDER ===== */
async function render(){
  map.innerHTML = "";
  await loadProgress();

  positions.forEach((branch,b)=>{
    branch.forEach((pos,i)=>{
      const id = `${b}-${i}`;
      createNode(id,pos[0],pos[1]);
      if(i>0) drawConnection(...branch[i-1],...pos);
    });
  });

  positions.forEach(branch=>{
    drawConnection(branch[2][0],branch[2][1],finalPos[0],finalPos[1]);
  });

  const finalUnlocked = [0,1,2,3].every(b => globalData.unlocked[`${b}-2`]);
  const f = createNode("final",finalPos[0],finalPos[1],true);
  if(finalUnlocked) f.classList.add("unlocked");
}

/* ===== INTERACTION ===== */
function openNode(id,isFinal){
  if(isFinal){
    if(![0,1,2,3].every(b=>globalData.unlocked[`${b}-2`])) return;
    currentNode = "final";
    panel.classList.remove("hidden");
    qText.textContent = finalQuestion.q;
    input.value = "";
    feedback.textContent = "";
    return;
  }

  if(!globalData.unlocked[id] && !id.endsWith("-0")) return;

  currentNode = id;
  const [b,i] = id.split("-").map(Number);
  panel.classList.remove("hidden");
  qText.textContent = questions[b][i];
  input.value = "";
  feedback.textContent = "";
}

document.getElementById("submitAnswer").onclick = async () => {
  const val = input.value.trim().toLowerCase();
  if(!val) return;

  if(currentNode === "final"){
    if(val === finalQuestion.a){
      window.open("/final-log","_blank");
    } else {
      feedback.textContent = "INCORRECT";
      feedback.style.color = "red";
    }
    return;
  }

  const [b,i] = currentNode.split("-").map(Number);
  if(val === answers[b][i]){
    await unlock(currentNode);
    feedback.textContent = "ACCESS GRANTED";
    feedback.style.color = "#00ffcc";
    await render();
  } else {
    feedback.textContent = "INCORRECT";
    feedback.style.color = "red";
  }
};

render();
</script>
</body>
</html>
