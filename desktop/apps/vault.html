<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>VAULT</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="vault.css">
</head>

<body>
  <div id="vaultRoot">
    <div class="vault-frame">
      <div class="vault-title">
        VAULT ACCESS NODE
      </div>
      <div class="vault-graph" id="vaultGraph">
      </div>
      <div class="vault-panel">
        <p class="vault-prompt">Select a node.</p>
        <div class="question-panel hidden" id="questionPanel">
          <p id="questionText"></p>
          <input
            type="text"
            id="answerInput"
            autocomplete="off"
            spellcheck="false"
          >
          <button id="submitAnswer">
            SUBMIT
          </button>
          <div id="feedback"></div>
        </div>
      </div>
    </div>
  </div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyBWWUW8Q-Y45U6WNlzL0-nkKDrkErcsf88",
  authDomain: "vaultgri.firebaseapp.com",
  projectId: "vaultgri",
  storageBucket: "vaultgri.firebasestorage.app",
  messagingSenderId: "390092427827",
  appId: "1:390092427827:web:6871164cf35f62347e8946",
  measurementId: "G-DQ80LXBBEP"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const vaultDoc = doc(db, "vault", "progress");

const branches = [
  ["1946", "preservation", "valentine"],
  ["obsolescence", "ebb-0", "watcher"],
  ["continuity", "echo", "delta-black"],
  ["1972", "observer", "human error"]
];

const questions = [
  ["DELTA founding year?", "Original directive?", "Who signed the charter?"],
  ["Primary threat?", "First system name?", "Hidden protocol?"],
  ["EBB obsession?", "Failed experiment?", "Lost archive?"],
  ["Monitoring began?", "System anomaly?", "Trust breach?"]
];

const finalQuestion = {
  q: "FINAL KEY PHRASE",
  a: "always watching"
};

const graph = document.getElementById("vaultGraph");
const panel = document.getElementById("questionPanel");
const questionText = document.getElementById("questionText");
const input = document.getElementById("answerInput");
const submitBtn = document.getElementById("submitAnswer");
const feedback = document.getElementById("feedback");

let currentNode = null;
let globalData = { unlocked: {} };

const CENTER_X = 300;
const CENTER_Y = 210;
const RADIUS = 160;

const branchAngles = [-135, -45, 135, 45];
const stepOffsets = [0.45, 0.75, 1.0];

function polar(angleDeg, dist) {
  const r = angleDeg * Math.PI / 180;
  return [
    CENTER_X + Math.cos(r) * dist,
    CENTER_Y + Math.sin(r) * dist
  ];
}

function drawConnection(x1, y1, x2, y2) {
  const line = document.createElement("div");
  const dx = x2 - x1;
  const dy = y2 - y1;

  line.className = "connection";
  line.style.width = Math.hypot(dx, dy) + "px";
  line.style.left = x1 + "px";
  line.style.top = y1 + "px";
  line.style.transform = `rotate(${Math.atan2(dy, dx)}rad)`;

  graph.appendChild(line);
}

function createNode(id, x, y, isFinal = false) {
  const n = document.createElement("div");
  n.className = "node" + (isFinal ? " final" : "");
  n.style.left = (x - 28) + "px";
  n.style.top = (y - 28) + "px";
  n.dataset.id = id;

  if (globalData.unlocked[id]) {
    n.classList.add("unlocked");
  }

  n.onclick = () => openNode(id, isFinal);
  graph.appendChild(n);
  return n;
}

async function loadProgress() {
  const snap = await getDoc(vaultDoc);
  globalData = snap.exists() ? snap.data() : { unlocked: {} };
  for (let b = 0; b < 4; b++) {
    const firstId = `${b}-0`;
    if (!globalData.unlocked[firstId]) {
      globalData.unlocked[firstId] = true;
    }
  }

  await setDoc(vaultDoc, globalData);
}


async function unlockNode(id) {
  globalData.unlocked[id] = true;
  await setDoc(vaultDoc, globalData);
}

async function buildMap() {
  graph.innerHTML = "";
  await loadProgress();

  const branchEnds = [];

  branchAngles.forEach((angle, b) => {
    let prev = null;

    stepOffsets.forEach((step, i) => {
      const [x, y] = polar(angle, RADIUS * step);
      const id = `${b}-${i}`;

      if (prev) drawConnection(prev[0], prev[1], x, y);
      createNode(id, x, y);

      prev = [x, y];
      if (i === 2) branchEnds.push([x, y]);
    });
  });

  branchEnds.forEach(([x, y]) => {
    drawConnection(x, y, CENTER_X, CENTER_Y);
  });

  const finalUnlocked = [0,1,2,3].every(b => globalData.unlocked[`${b}-2`]);
  const finalNode = createNode("final", CENTER_X, CENTER_Y, true);

  if (finalUnlocked) finalNode.classList.add("unlocked");
}

function openNode(id, isFinal) {
  if (isFinal) {
    if (![0,1,2,3].every(b => globalData.unlocked[`${b}-2`])) return;
  } else {
    if (!globalData.unlocked[id]) return;
  }

  currentNode = id;
  panel.classList.remove("hidden");
  input.value = "";
  feedback.textContent = "";

  if (isFinal) {
    questionText.textContent = finalQuestion.q;
  } else {
    const [b, i] = id.split("-").map(Number);
    questionText.textContent = questions[b][i];
  }
}

submitBtn.onclick = async () => {
  if (!currentNode) return;

  const val = input.value.trim().toLowerCase();
  if (!val) return;

  if (currentNode === "final") {
    if (val === finalQuestion.a) {
      window.open("/final-log", "_blank");
    } else {
      feedback.textContent = "INCORRECT";
      feedback.style.color = "red";
    }
    return;
  }

  const [b, i] = currentNode.split("-").map(Number);

  if (val === branches[b][i]) {
    await unlockNode(currentNode);
    feedback.textContent = "ACCESS GRANTED";
    feedback.style.color = "#00ffcc";
    await buildMap();
  } else {
    feedback.textContent = "INCORRECT";
    feedback.style.color = "red";
  }
};

buildMap();
</script>
</body>
</html>
